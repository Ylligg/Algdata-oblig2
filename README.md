# Obligatorisk oppgave 2 i Algoritmer og Datastrukturer

Denne oppgaven er en innlevering i Algoritmer og Datastrukturer. 
Oppgaven er levert av følgende studenter:

* Ylli Gashi, s364574, s364574@oslomet.no
* Sena Uysun, s364728, s364728@oslomet.no
* Håkon Skaftun, s364776, s364776@oslomet.no
* Oliver Preber, s364763, s364763@oslomet.no

# Arbeidsfordeling

I oppgaven har vi hatt følgende arbeidsfordeling:
* Ylli har hatt hovedansvar for oppgave 1, 2, 4, 5. 
* Sena har hatt hovedansvar for oppgave 3 og 10. 
* Håkon har hatt hovedansvar for oppgave 4 og 7.
* Oliver har hatt hovedansvar for oppgave 8 og 9. 

# Oppgavebeskrivelse

I oppgave 1 så opprettet vi den dobelte linkede listen ved først å se om de første verdiene er null, hvis de er så blir hode den første verdien som ikke er null og den blir første node (current). etter det så søkes det gjennom listen, om en element er null så skippes den og hvis a[i] != null så lages en ny node (ny). for å få relasjon med hverandre så er ny sin forrige current og current sin neste ny. etter relasjonen så blir nye noden current. når det skjer så har vi klart å få en ny node inn så blir antall plussa. når løkken er ferdig så blir halen current siden current var den siste noden. antall() blir skrevet ut og tom() er true hvis den er tom og vice versa.

I oppgave 2 så lagde vi tostring() og omvendtstring(). hvis antall er 0 så vil det returne en tom liste []. etter det så blir en stringbuilder opprettet og vi lager en node som heter cur. vi går gjennom en løkke for å adde elementene i rekkefølge ved å appende cur.verdi og når det er gjort så går vi videre til cur.neste. For det siste elementet så blir det appenda kun verdien og ikke en komma slik at tabellen ender som "4]" og ikke "4,]". når alt er ferdig så returner den ut i tostring(). det samme skjer i omvendtstring() bare at det starter på den siste posisjonen av løkka og går mot 0. på den måten så kan vi skrive ut listen i motsatt retning.

I oppgave 3.a lagde vi først hjelpemetoden Node<T> finnNode(int indeks). Så sammenlignet vi indeks og antall/2 ved å bruke en if løkka. Hvis indeksen er mindre enn antal/2, skal nåværende verdi være lik hode.Så lagde vi en for løkka som skal letes etter noden starte fra den nåværende verdien og gå mot høyre ved hjelp av neste pekeren.
Neste steg var å lage  else løkka (hvis antall/2 er ikke mindre enn indeksen ) som tar inn en for løkka og returnerer den nåværende verdien. Hvis  antall/2 er ikke mindre enn indeksen betyr det at nåværende verdi er lik hale og for løkkan skal letes etter noden starte fra halen og gå mot venstre ved hjelp av forrige pekeren. 
Så lagde vi metoden public T hent(int indeks) ved å bruke finnNode() og metoden skal returnere "nåværende.verdi". For å sjekke indeksen la vi til  metoden indeksKontroll inn i metoden oppdater. Metoden indeksKontroll var allerede i Liste.java. Derfor lagde vi ikke en ny indeksKontroll metoden i DobbeltLenketListe.java filen. Til slutt lagde vi metoden oppdater som skal ersatte verdien på plass indeks med nyverdi og returnere 
"nåværende.verdi". For å kunne sjekke at null verdier ikke legges inn , skrev vi  Objects.requireNonNull(nyverdi, "verdi er null") innenfor metoden oppdater. Så la vi til endringer++ innenfor metoden oppdater for at variabelen endringer skal økes.
I oppgave 3.b lagde vi først metoden Liste<T>  subliste(int  fra,  int  til). Først lagde vi en hjelpemetode for å kunne sjekke om indeksene fra og til er  lovlige. Så byttet vi ord antall med ortdet tablengde. Så antall=til-fra. Så lagde vi en if løkka som skal returneres en tom liste hvis tabellengde/antall er lik eller mindre enn null. Vi brukte deretter en while-løkke for å skrive ut listeelementene med to spesifiserte intervaller. Hvis antall er større enn 0, vil elementene i de to spesifiserte intervaller bli skrevet ut ved hjelp av leggInn-metoden.

I oppgave 4 startet vi med metoden indeksTil(T verdi). Vi brukte en while-løkke som går gjennom listen fra starten. Vi setter en Node current til verdi av hode (den første Noden) og sjekker om verdien av noden er lik verdien vi søker etter gjennom løkka. Vi har også lagt til en int indeks som teller indeksen vi foreløpig er på. Hvis verdien vi søker etter er lik verdien til Node current returneres indeksen, hvis ikke økes indeksen med 1 og current endres til current.neste. Så lenge current ikke er null vil det søkes videre til slutten av listen og vil returnere -1 hvis verdien ikke finnes. 
Del 2 av oppgaven lagde vi public boolean inneholder(T verdi). Denne returnerer enten true eller false. Da brukte vi en if-setning som bruker indeksTil-funksjonen og sjekker verdien. Hvis verdien ikke er i listen vil funksjonen indeksTil returnere -1 så da vil funksjonen inneholder(T verdi) returnere false. Hvis indeksTil returnerer noe som helst annet enn -1 skal funksjonen returnere true. 

I oppgave 5 så lagde vi legginn med indeks og verdi. det vi gjør først er å ha en requirenonnull og indekskontroll for å se om det er mulig for å sette inn en ny node. det som skjer etter det er om antallet er 0 eller lik indeks (altså siste node) så legges inn en ny node. etter det så oppretter vi tre pekere q,p og r, hvor r er den noden vi skal finne og p er elemente før r og q er en ny node som skal være mellom q og r. om indeks er 0 så blir r sin forrige q og q blir hode siden den er første node. om indeks ikke er 0 så vil p sin neste være q og r sin forrige vil være q. når det er gjort så vil antallet og endringer økes.

I oppgave 6 brukte jobbet vi i utgangspunktet ut ifra kildekode fra metodene boolean fjern(T verdi) og T fjern(int indeks) fra delkapittel 3.3.3 i kompendiet. For metoden public T fjern(int indeks) starter vi med å sjekk om det finnes verdier i lista og om indeksen satt inn som parameter ikke overstiger eller er lik antallet i lista. Hvis dette er tilfelle så vil man få en feilmelding siden det ikke er nødvendig å kjøre metoden videre. Vi lager en variabel T temp som skal inneholde verdien vi ønsker å finne. Vi laget diverse if-setninger som kartlegger om indeksen er enten hode, hale eller noe imellom i listen og endrer hode og hale sine neste og forrige ut ifra resultatet. Temp blir også da satt til verdien av hode/hale før noe annet endres. Hvis indeksen ikke er hode eller hale men noe imellom så lager vi pekere Node<T> p og r som settes til noden foran og etter indeksen vi leter etter. Node<T> q settes som p.neste og er da verdien vi leter etter. Temp blir satt lik q.verdi. Til slutt gjør vi så pekerne peker på hverandre og ikke på q siden denne verdien skal fjernes. Helt til slutt senkes antall med 1 siden q nå er fjernet og endringer økes med 1 og så blir temp returnert som inneholder verdien til den noden som ble fjernet.

For public boolean fjern(T Verdi) starter vi med å sjekke at parameterverdien ikke er null. Da returneres false da listen ikke inneholder null-verdier. Vi definerer en boolean funnet som er satt til false helt til verdien eventuelt blir funnet og den endres til true. Vi definerer en Node<T> q lik hode (starten av listen) og to pekere p og r som peker til nodene før og etter q. Vi har brukt en while-løkke som kjører så lenge q ikke er null. I denne løkka har vi en if-setning som sjekker om verdien av q er lik parameterverdien. Hvis q er lik parameterverdien senkes antall med 1, endringer økes med 1 og boolean funnet endres til true siden verdien fins i listen og det utløser en break; som bryter ut av while-løkken. Hvis q ikke hadde vært lik parameterverdien flyttes q, p og r videre slik at hele listen går gjennom løkka hvis verdien ikke blir funnet fram til q blir null og har gått gjennom hele lista. Hvis ikke verdien ble funnet er q lik null og det blir returnert false. Hvis antallet har blitt 0 etter fjerningen settes hode og hale til null. Videre har vi satt opp if-setninger for om q var lik hode, hale eller noe imellom. Her endres hode, hale og pekere ut ifra resultatet slik at verdien q blir fjernet fra listen. Til slutt returnerer vi boolean funnet som er false hvis verdien ikke ble funnet og true hvis den ble funnet.

I oppgave 7 startet vi med Måte 1: her brukte vi en for-løkke til å gå gjennom lista fra start med å lage en Node temp som er lik hode og løkka fungerer kun når temp har en verdi (ikke null). Vi lager også en Node next som peker på noden etter temp. Alle temp sine verdier og pekere blir satt til null og vi setter temp lik next. Slik fortsetter løkka fram til alle er fjernet og temp=null. Til slutt utenfor løkka settes hode og hale til null, antall til 0 og endringer økes med 1. Denne metoden er hentet fra kildekoden for metoden clear() i klassen LinkedList i Java som beskrevet i oppgaven (se link i koden).
Måte 2 er kodet ved å lage en Node temp med verdien til hode. Deretter brukte vi en while-løkke som kjører gjennom så lenge temp ikke er null. Løkka kaller på metoden fjern(0) som fjerner det første elementet i lista. Da vil resterende elementer (hvis flere) forskyves ett hakk mot hode og en ny verdi kommer i indeks 0, på denne måten kalles fjern(0) helt til alle elementer i lista har vært i indeks 0 og blitt fjernet. På samme måte som i måte 1 blir hode og hale satt til null, antall til 0 og endringer økes med 1.

I oppgave 8 startet vi med å implemetere T next() hvor vi sjekke om endrinege stemte med iterasjonsendringene og hvis ikke kaste en passende melding, deretter sjekket vi om hasNext() var true. Satte til slutt fjernOK til true og returnerte verdien. Lagde metoden hvor iteratorklassen ble returnert. I neste metode satta vi pekeren denne til noden som indeksen hører til og resten av metoden var slik den var ferdigkodet. I oppgave 8d brukte vi metoden indeksKontroll() for å sjekke om indeksen var lovlig eller ikke. Dermed brukte vi forrige metode til å returnere en instans av iteratorklassen.

I oppgave 9 så fiksa vi remove(). det vi gjorde først var å se ulike feil som hvis fjernok var false da kastes det en illegalstateexception. om endringer ikke er lik iteratorendringer så er det feil også. når disse kravene er fullført så vil vi gjøre fjerneok false. hvis antallet er 1 så vil vi ende opp med ingenting altså hode=null og hale=null. om denne er null så fjernes hale og hale.forrige blir nye halen. neste er for hode, denne.forrige er hode, men vi gjør hode blir neste element og hode sin gammle posisjon blir null. ellers så har vi p og r som blir connected sammen som gjør at q ikke har noen relasjoner som gjør at den blir borte. når alt er ferdig så økes endringer og iteratorendringer og antall synker